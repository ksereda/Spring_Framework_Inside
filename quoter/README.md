Spring.
Делаем через XML




- task 1: quoter

Делаем свою аннотацию `@InjectRandomInt` и делаем для нее свой `BeanPostProcessor`.

Понятие "Двухфазовый конструктор".





- task 2: quoter

Чтобы все классы, над которыми стоит `@Profiling` - профилировались (т.е. в лог писалось время сколько метод работает).

Для этого надо замерить время начала работы, действие, время конца работы и вывести это. 
Будет какой-то `BeanPostProcessor`, который будет относиться к этой аннотации: он будет получать bean от BeanFactory, и будет проверять, не стоит ли над классом аннотация `@Profiling` и если стоит, то он должен будет в каждый метод этого bean дописывать логику, связанную с профайлингом.
В java мы не сможем просто взять и подставить новую логику в уже существующий метод. Надо будет сгенерировать новый класс `(proxy)`, но никто не должен заметить подмены! 
1. Либо он должен наследовать от оригинального класса и переопределять его методы и добавлять туда свою логику - `CGLib` (считается хуже, т.к. мы не от любого класса можем наследовать, final методы и т.д.)
2. либо он должен имплементировать те же самые интерфейсы - `Dynamic proxy`


Идем в папку с установленой java. Для ubuntu это:
/usr/lib/jvm/java-8-oracle/bin/ и там запускаем jvisualvm
Add "visual mbeanserver plugin" for visualvm: Tools - Plugins
Ставим флаг true - идет профилирование (т.к. над нашим классом висит `@Profiling`), ставим false - не идет профилирование.

В итоге мы эту аннотацию `@Profiling` можем ставить над любым bean и каждый раз, когда мы будем включать профилирование (true/false) он будет профилироваться.
Наш BeanPostProcessor меняет логику нашего класса.



