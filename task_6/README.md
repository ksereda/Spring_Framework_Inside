task 6: Циркулярная зависимость между бинами

______________________________________

   
Циркулярная зависимость между бинами

`В примере будет NPE`


Как уйти от того, чтобы логику вызывать в `@PostConstruct` ?
`@PostConstruct` - это иными словами init() метод, а на этапе init() метода бин еще не до конца сконфигурирован и поэтому если у бина есть какие-то proxy, аспекты, которые для него что-то делают, этого на этапе `PostConstruct` еще не существует.
Поэтому не надо ставить `@PostConstruct` над методом, в котором мы вызываем `init()` метод. Над самим `init()` методом надо поставить `@PostConstruct`, а над тем методом, где был `@PostConstruct` мы поставим `@Main (самописная аннотация)`

_______

Выводы:
1) Старайтесь избегать циркулярных зависимостей, стройте правильную архитектуру
2) Нельзя использовать 1@PostConstruct1 для вызова бизнес логики
3) Используйте @Main для бизнес логики - нет такой аннотации в Spring, это самописная аннотация. (Например: мы хотим, чтобы методы, помеченные аннотацией `@Main` поднимались, когда весь контекст уже поднялся. См предыдущие примеры).

По сути так сделать нельзя по двум причинам:
1) Во первых, если мы из контекста начнем вытаскивать все бины при помощи `listener`, то мы вытащим даже те бины, которые, допустим были lazy или prototype и т.д.
2) Если мы вытаскиваем `getBean()` то дальше мы должны залезть в его класс и поискать там аннотацию @Main. А если этот бин был завернут в `proxy`, то когда мы сделаем `getClass()` - мы получим имя типа "$Proxy18" и никакого `@Main` в методах там не найдем.

_____

Для решения этой задачи надо взять `BeanDefinitions`.
Достаем все `BeanDefinitions`, пробегаемся по ним и смотрим, из какого класса они были сделаны, ищем методы, вытаскиваем бин, когда нашли аннотацию `@Main` и запускаем этот бин.