task 8: Аннотации в интерфейсах

______________________________________


Аннотации в интерфейсах


- subtask_1

Нельзя ставить `@PostConstruct` над методом, который что-то принимает!
- Если ставим `@Autowired` над `полем` - то сетится поле,
- Если ставим `@Autowired` над `конструктором` - то Spring поймет, что через этот конструктор надо создавать объект и туда все заинжектит,

Но если допустим у нас есть 1 единственный конструктор с параметрами, то даже не надо ставить `@Autowired`, т.к. Spring сам поймет что с ним делать.
- Если ставим `@Autowired` над `методом` - то с точки зрения Spring этот метод расценивается как setter, запускается и в него инжектится то, что нужно. 

_________

- subtask_2

Мы здесь в интерфейсе Car поставили аннотацию `@PostConstruct` над методом.

Аннотации в интерфейсах `НЕ работают!`
Но как сделать чтобы работали ?

Можно написать свой `BeanPostProcessor`. 

    А если без него ?

Тогда напишем свой `BeanFactoryPostProcessor`.

`BeanPostProcessor` содержит 2 метода: 1 вызывается до `init()` метода, второй после. 
Как может быть такое, что `BeanPostProcessor` и отвечает за вызов `PostConstruct` ???

Идеологически было бы правильней сделать чтобы не `BeanPostProcessor` отвечал за запуск `PostConstruct`, а чтобы еще на этапе `до PostConstruct` `(т.е. на этапе создания BeanDefinitions)` кто-то находил, что у него есть `PostConstruct` через аннотация `@PostConstruct` над методом и записывал эту информацию в `BeanDefinitions` (как будто это прописали в XML)

____________

- subtask_3
    
Здесь мы в интерфейсе Ship поставили аннотацию `@PostConstruct` и прописали бин Ship в `java-config`.
Для бинов, прописанных в `java-config`, в `BeanDefinition` нет информации о классе, из которого сделан этот бин.

Здесь уже предыдущее решение не сработает!
т.к. в прошлом примере `(task_7 - version_2)` мы написали `BeanPostProcessor`, который чинит подобный проблемы. `Но это - BeanPostProcessor`,
потому что только `BeanPostProcessor` может что-то починить на этапе `"до"`.

    В какой момент мы можем узнать из какого класса создался бин ? 
    
Когда создался объект и сделав у него `getClass()`, а это уже происходит на этапе `"после"`. Но мы хотим делать это на этапе `"до"`.

Мы имеем ввиду, что хотим зарегистрировать в `BeanDefinition` что-то `до` того, как бин создался.

Нам надо написать код, который сможет достать Ship (это м.б. либо класс, либо интерфейс, нам не важно).

У интерфейса `BeanDefinition` есть много имплементаций:
- AbstractBeanDefinition
- AnnotatedBeanDefinition - если используем аннотацию @Component
- `ConfigurationClassBeanDefinition`  -  с помощью него мы можем узнать то, что нам нужно (какого типа и из какого класса создался бин)
- GenericBeanDefinition
- ScannedGenericBeanDefinition
	
Можно было бы попробовать использовать `ConfigurationClassBeanDefinition`, но он private static и находится в private пакете.

Мы сделаем `свой класс`, в котором будет метод `resolveClassNameFromJavaConfig`, с помощью которого мы обращаемся ко внутреннему вложенному приватному
классу `ConfigurationClassBeanDefinition`, который находится внутри класса `ConfigurationClassBeanDefinitionReader`, кастим его, полю `factoryMethodMetadata` ставим параметр `= true` и с помощью
`MethodMetadataReadingVisitor` возвращаем `нужный нам тип`.

    class ConfigurationClassBeanDefinitionReader {
        ...
        private static class ConfigurationClassBeanDefinition extends RootBeanDefenition implements AnnotatedBeanDefinition {
            ...
        }
        ...
    }

_____________

- subtask_4

Мы хотим 2 init() метода в интерфейсе (сделатыь еще один default метод).

Начиная с версии `4.2` Spring начал сам поддерживать методы, помеченные `@PostConstruct` в интерфейсах, если у них есть `default методы`.
Т.о. один раз `@PostConstruct` запускается при помощи Spring, а второй раз - потому что мы его зарегистрировали (см код)
    
    init() метод у BeanDefinition - он всего один, а PostConstruct - сколько угодно.

______________

- subtask_5

Рассмотрим пример с 2 модулями одного приложения. 

В `модуле 1` есть `Config1`, в котором обьявлены 3 бина со своей аннотацией `@App1` и сервис `Service1`, который инжектит их в list.

Также есть `модуль 2`: в `Config2` вручную создаем какой-то лист и в `Service2` прописан бин этого list.

    Что заинжектится в list в обоих модулях ?
    
На версии `4.2` - не отработает (т.к. бина с `@App2`, который является String, не было). Spring видит аннотацию `@Autowired` над list (он не пытается найти бин который list), он смотрит тип дженерика. 
Можно было бы сделать так:
 * Указать ArrayList<String> вместо List<String> - но принято работать с интерфейсами.
 * List<List<String>> list
 * Можно не делать бин, который является list.
 * Или использовать `Spring 4.3+`
 
Начиная с версии `4.3` - отработает: в модуль 1 попадут только те, которые помечены аннотацией `@App1`, а в модуль 2 - те, что помечены `@App2`.

Т.е. если есть конкретно бин, который является list (который нам подходит), Spring возьмет его и заинжектит, но если его нет, то тогда Spring найдет все бины, построит из них list и заинжектит его.
