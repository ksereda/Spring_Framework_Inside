package interfaces.subtask_4;

import javax.annotation.PostConstruct;

/**
 * При первом запуске отработают все (4 System.out.println)
 * Утверждение типа: "Если байткод уже построен, не важно сколько раз мы будем запускать, результат будет одинаоквый" здесь неверно.
 * При следующем запуске может быть 2 или даже 3.
 * При следующем - возможно снова 4.
 *
 * Начиная с версии 4.2 Spring начал сам поддерживать методы, помеченные @PostConstruct в интерфейсах, если у них есть default методы.
 * Т.о. один раз @PostConstruct запускается при помощи Spring, а второй раз - потому что мы зарегистрировали!
 * init() метод у BeanDefinition - он всего один, а PostConstruct - сколько угодно.
 * Если нам повезло: Мы зарегистрировали метод, аннотированный @PostConstruct который абстрактный (он запустится Spring-ом, т.к. он теперь зарегистрированный, а второй запустится т.к. Spring поддерживает аннотацию @PostConstruct над default методами)
 * А если не повезло и так совпало и мы зарегистрировали как раз тот метод, который и так бы запустился (т.е. default метод), тогда он запустится 1 раз, т.к. Spring дважды один метод запускать не будет (если он уже был продекларирован как init() метод, то Spring его не запустит через PostConstruct)
 *
 * 2 варианта:
 * 1) отказаться от этой схемы
 * 2) нам надо и то и другое. Тогда можем в InitMethodRegistryBeanFactoryPostProcessor там, где ищем аннотацию PostConstruct добавить еще &&!method.isDefault() - тогда всегда будем получать 4 System.out.println)
 * Но здесь есть проблема: если этот default метод кто-то перепишет в имплементации, то будет проблема, Spring его уже точно не запустит (он его не увидит).
 *
 * Например у нас етсь несколько default методов в интерфейсе, помеченных @PostConstruct и мы хотим запустить их все. Мы можем сгенерировать какой-то proxy класс, который будет запускать все эти методы.
 */

public interface Car {

    @PostConstruct
    void speed();

    @PostConstruct
    default void test() {
        System.out.println("This is default method!");
    }

}
